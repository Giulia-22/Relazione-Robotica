
\documentclass{report}

\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{import}
\usepackage{todonotes}
\usepackage{color}
\usepackage{rotating}
\usepackage[hidelinks]{hyperref}
\usepackage{url}
\usepackage{pdfpages}
\usepackage{siunitx}
\usepackage{pdflscape}
\usepackage{subfig}
\usepackage[euler]{textgreek}
\usepackage{mhchem}

\usepackage{multirow}

\usepackage{enumerate} 
\usepackage{amsmath}
\usepackage{amsfonts}

\usepackage[signatures,swapnames,sans]{frontespizio}

\usepackage{geometry}
\geometry{portrait, margin=3cm}
\usepackage{siunitx}
\usepackage{booktabs}

\renewcommand*\figurename{Figura}

\newcommand{\sub}[1]{\textsubscript{#1}}
\newcommand{\super}[1]{\textsuperscript{#1}}
\newcommand{\parallelsum}{\mathbin{\!/\mkern-5mu/\!}}

\newcommand{\Fig}[0]{Fig.}

\usepackage{listings} %Per inserire codice
%\usepackage[usenames]{color} %Per permettere la colorazione dei caratteri

\lstnewenvironment{codice_arduino}[1][]
{\lstset{basicstyle=\small\ttfamily, columns=fullflexible,
keywordstyle=\color{red}\bfseries, commentstyle=\color{blue},
language=C++, basicstyle=\small,
numbers=left, numberstyle=\tiny,
stepnumber=2, numbersep=5pt, float=*, #1}}{}

\usepackage{titlesec}

\titleformat{\chapter}{\normalfont\huge}{}{20pt}{\huge\bfseries}

\linespread{1.3}


%% COMANDI UTILI
%\begin{table}[h]
%	\centering
%	\begin{tabular}{|c|c|c|}
%	\cline{2-3} 
%	\multicolumn{1}{c|}{} & \textbf{Valore nominale} & \textbf{Valore misurato}\\ 
%		%\hline
%		%{} & \textbf{Valore nominale} & \textbf{Valore misurato} \\ 
%		\hline
%		$\mathbf{R_1}$ & \SI{18}{k\ohm} & \SI{17.977}{k\ohm} \\ 
%		\hline
%		$\mathbf{R_2}$& \SI{1.8}{k\ohm} & \SI{1.815}{k\ohm} \\ 
%		\hline
%	\end{tabular}
%\caption{Misure delle resistenze utilizzate per il circuito.}
%\label{table:mis_res}
%\end{table}
%\begin{figure}[h!]
%\centering
%\includegraphics[height=6.5cm]{immagini/TEK00018}\\(a)\\[1ex]
%\includegraphics[height=6.5cm]{immagini/TEK00019}\\(b)
%\caption{Risposta del circuito con accoppiamento DC (a) e accoppiamento AC (b).}
%	\label{figura:accopp}
%\end{figure}

\begin{document}
%\addtocounter{chapter}{+4}
	\begin{frontespizio}
		\Margini{3cm}{3cm}{3cm}{3cm}
		\Universita{Bergamo}
		\Logo[43.332mm]{unibg-mark}
		\Divisione{Scuola di Ingegneria}
		\Corso[Laurea Magistrale]{Ingegneria Informatica}
		\Titolo{Laboratorio di Robotica}
		\Sottotitolo{Documentazione attività di laboratorio }
		\Punteggiatura{}
		\NRelatore{Prof.}{Prof.}
		\Relatore{Davide Brugali}
		\Candidato[1058231]{Giulia Allievi}
		\Candidato[1059640]{Martina Fanton}
		\Annoaccademico{2022--2023}
		\begin{Preambolo*}
			\usepackage[italian]{babel}
			\usepackage[T1]{fontenc}
			\usepackage[utf8]{inputenc}
			\usepackage{microtype}
			\usepackage{lmodern}
			\graphicspath{{img/}}
			
			\renewcommand{\frontinstitutionfont}{\fontsize{14}{17}\bfseries\scshape}
			\renewcommand{\fronttitlefont}{\fontsize{17}{21}\bfseries\scshape}
			\renewcommand{\frontfootfont}{\fontsize{12}{14}\bfseries\scshape}
		\end{Preambolo*}
	\end{frontespizio}

%----------------------------------------------------------------------------------------
%	PAGINA BIANCA
%----------------------------------------------------------------------------------------
%\newpage
%\null
%\thispagestyle{empty}
%\newpage

%----------------------------------------------------------------------------------------
%	INDICE
%----------------------------------------------------------------------------------------
\tableofcontents

%----------------------------------------------------------------------------------------
%	INTRO
%----------------------------------------------------------------------------------------
\chapter{Introduzione}
L'obiettivo del nostro progetto è quello di fornire le coordinate e l'orientamento della pinza ad un robot, al fine di potersi posizionare per afferrare un oggetto. Le coordinate e l'orientamento vengono calcolate da un'opportuna libreria (nel nostro caso dalla libreria \textit{Grasp Pose Generator, GPG}), la quale necessita delle informazioni dell'oggetto inquadrato sotto forma di una nuvola di punti, la point cloud, che verrà fornita attraverso la \textit{Stereo Camera ZED}. Il software del progetto sarà realizzato utilizzando il \textit{Framework STAR}. \par
La \textit{Stereo Camera ZED} è dotata di vari sensori, per esempio l'accelereometro e il giroscopio, ma nella nostra applicazione serviranno solo i dati delle immagini, in particolare solo quelli della point cloud. La fotocamera stereoscopica ha un range di profondità compreso fra \SI{30}{c\meter} e \SI{20}{\meter} (fonte: \textcolor{blue}{\underline{\href{https://www.stereolabs.com/assets/datasheets/zed2-camera-datasheet.pdf}{datasheet}}}), perciò gli oggetti da inquadrare dovranno essere posizionati ad una distanza compresa in questo intervallo. \par
Di seguito, nel capitolo \ref{librerie} verranno analizzate due diverse librerie che si possono utilizzare per ottenere i dati relativi alla posizione e all'orientamento della pinza del robot, mentre nel capitolo \ref{integrazione} verranno descritti i passi necessari per integrare, compilare ed eseguire il progetto. Infine, nel capitolo \ref{risultati} verranno mostrati i risultati finali.
\newpage
\chapter{Librerie}\label{librerie}
Prima di costruire l'applicazione finale (in cui è stata integrata soltanto la libreria GPG), sono state analizzate due diverse librerie \textit{stand-alone}, la \textit{Grasp Pose Generator} (GPG), la cui documentazione è reperibile al seguente \textcolor{blue}{\underline{\href{https://github.com/atenpas/gpg}{link}}}, e la \textit{Grasp Pose Detection} (GPD), la cui documentazione è invece disponibile al seguente \textcolor{blue}{\underline{\href{https://github.com/atenpas/gpd}{link}}}.\par
\section{Grasp Pose Generator (GPG)}\label{GPG}
Questa libreria permette di individuare, data la point cloud di un oggetto contenuta in un file di tipo \texttt{.pcd}, un certo numero di possibili pinze con cui il robot può afferrare l'oggetto stesso. Questo numero di pinze restituite in output viene definito dall'utente nel file di configurazione della libreria. \par
Per poter eseguire la libreria, innanzitutto si deve scaricare lo zip della libreria da Github (\textcolor{blue}{\underline{\href{https://github.com/atenpas/gpg}{link}}}) estraendone il contenuto, rinominandolo come \texttt{grasp\_candidates\_generator} e spostandolo in una directory scelta dall'utente. Poi vanno scaricate tutte le librerie che la libreria GPG richiede per il suo funzionamento, ovvero \textit{PCL} (necessaria per elaborare la point cloud), \textit{Eigen} (necessaria per eseguire operazioni con vettori e matrici) e \textit{VTK} (necessaria per la visualizzazione della point cloud), aprendo un nuovo terminale ed eseguendo in esso i comandi:
\begin{verbatim}
  sudo apt install libpcl-dev
  sudo apt install libeigen3-dev
  sudo apt-get install vtk6
\end{verbatim}
Ora si può procedere con l'esecuzione della libreria GPG. Per prima cosa si effettua la compilazione eseguendo nel precedente terminale i seguenti comandi:
\begin{verbatim}
  cd <location_of_your_workspace>  
  cd grasp_candidates_generator
  mkdir build && cd build
  cmake ..
  make
  sudo make install
\end{verbatim}
Successivamente va eseguito anche il prossimo comando per l'esecuzione effettiva della libreria:
\begin{verbatim}
  ./generate_candidates ../cfg/params.cfg ~/data/<point_cloud_name_file>.pdc
\end{verbatim}
In questo modo si visualizza a video un disegno in cui vengono visualizzati i vettori normali alla superficie inquadrata, però per visualizzare la point cloud dell'oggetto in uno spazio tridimensionale con le pinze individuate dalla libreria è necessario cliccare nella tastiera sul tasto Q. Per chiudere anche questa nuova finestra va premuto nuovamente il tasto Q. Per entrambe le finestre, per cambiare lo zoom bisogna usare lo scroller del mouse, per muoversi sulla point cloud bisogna invece trascinare con il cursore. 
\todo{Mettere alla fine un'immagine con la visualizzazione delle prese e delle info date dal terminale}
\section{Grasp Pose Detection (GPD)}\label{GPD}
A differenza della libreria precedente, in questa libreria è integrato anche un classificatore per riconoscere gli oggetti afferrabili. La libreria GPD restituisce in output le pinze individuate, analogamente alla libreria GPG, ma per ogni presa viene specificato anche il suo score, che nell'immagine viene reso utilizzando dei diversi colori (verde per le pinze con score maggiore, che sono quelle corrette; giallo e arancione per quelle di score intermedio, che sono le prese accettabili; rosso per quelle con score basso, che sono da considerarsi non accettabili). Anche per questa libreria il numero delle pinze è definito dall'utente nel file di configurazione. \par
Per poter eseguire la libreria, innanzitutto si deve scaricare lo zip della libreria da Github (\textcolor{blue}{\underline{\href{https://github.com/atenpas/gpd}{link}}}) estraendone il contenuto, rinominandolo come \texttt{gpd} e spostandolo in una directory scelta dall'utente. Poi vanno scaricate tutte le librerie che la libreria GPD richiede per il suo funzionamento, ovvero \textit{PCL} (necessaria per elaborare la point cloud), \textit{Eigen} (necessaria per eseguire operazioni con vettori e matrici), \textit{VTK} (necessaria per la visualizzazione della point cloud) e \textit{OpenCV} (necessaria per eseguire la detection delle pinze), aprendo un nuovo terminale ed eseguendo in esso i comandi:
\begin{verbatim}
  sudo apt install libpcl-dev
  sudo apt install libeigen3-dev
  sudo apt-get install vtk6
  sudo apt install libopencv-dev
\end{verbatim}
Ora si può procedere con l'esecuzione della libreria GPD. Per prima cosa si effettua la compilazione eseguendo nel precedente terminale i seguenti comandi:
\begin{verbatim}
  cd <location_of_your_workspace> 
  cd gpd
  mkdir build && cd build
  cmake ..
  make -j
  sudo make install
\end{verbatim}
Successivamente va eseguito anche il prossimo comando per l'esecuzione effettiva della libreria:
\begin{verbatim}
  ./detect_grasps ../cfg/eigen_params.cfg ../tutorials/krylon.pdc
\end{verbatim}
Questo comando viene eseguito sulla point cloud contenuta nel file \texttt{krylon.pcd} fornito da esempio nella libreria, ma nel comando può essere inserito qualsiasi altro file di tipo \texttt{.pcd}. \par
In questo modo si visualizzano a video i vettori normali alla superficie della point cloud in uno spazio tridimensionale, però per visualizzare anche le pinze individuate dalla libreria è necessario cliccare nella tastiera sul tasto Q. Per vedere il numero scelto di pinze migliori, che  vengono distinte in base al loro colore secondo lo score che le caratterizza, è necessario premere di nuovo il tasto Q. Per chiudere anche questa nuova finestra va premuto nuovamente il tasto Q.
\todo{Mettere alla fine un'immagine con la visualizzazione delle prese e delle info date dal terminale}

\newpage
\chapter{Integrazione}\label{integrazione}
In questo capitolo, verranno descritti i passi seguiti per ottenere l'applicazione finale. Innanzitutto è importante inizializzare le variabili d'ambiente di STAR in un nuovo terminale. Per fare ciò, bisogna eseguire questi comandi nel terminale:
\begin{verbatim}
  cd STAR
  cd AutonomousRobots
  . env-star.sh
\end{verbatim}
A questo punto, si inserisce la password (che è \texttt{unibg}) ed il terminale è pronto per essere utilizzato. L'inizializzazione va ripetuta ogni volta che si vuole utilizzare un nuovo terminale per eseguire delle azioni su STAR. 
\section{Libraries}
Per prima cosa, andiamo a copiare e compilare la libreria GPG descritta nella sezione precedente nella sottocartella \texttt{others} della cartella \texttt{Libraries} di STAR. Per fare ciò eseguiamo i seguenti comandi in un terminale, dopo aver raggiunto la cartella \texttt{others}:
\begin{verbatim}
  cd <location_of_your_workspace>  
  cd grasp_candidates_generator
  mkdir build && cd build
  cmake ..
  make
  sudo make install
\end{verbatim}
Per eseguire la libreria, si deve digitare il comando seguente all'interno della cartella \texttt{build}:
\begin{verbatim}
  ./generate_candidates ../cfg/params.cfg ~/gpg/tutorials/<point_cloud_name_file>.pcd
\end{verbatim}
La libreria appena importata funziona fornendogli in ingresso un file con estensione \texttt{.pcd} che contiene le informazioni sui punti della point cloud, però nel nostro caso la point cloud non sarà salvata su un file, ma verrà fornita dalla fotocamera stereoscopica. Modifichiamo quindi la libreria per fare in modo che riceva in ingresso non un file, ma una struttura dati denominata \texttt{CloudCamera} che è un riferimento alla struttura dati \texttt{pcl::PointCloud$<$pcl::PointXYZRGBA$>$::Ptr}. Quest'ultima variabile è un vettore contenente dei punti nel formato XYZRGBA: ogni punto è caratterizzato da 4 campi, i primi tre (X, Y, e Z) sono di tipo double e contengono le informazioni relative alle coordinate di quel punto in metri, invece l'ultimo campo, RGBA, è un intero senza segno a 32 bit in cui si codifica l'informazione sul colore. Ogni parametro del colore (R, G, B e A) è memorizzato in 8 bit e questo significa che ognuno di questi valori può variare da 0 a 255, perciò possono essere rappresentati fino a $\displaystyle{2^{32}=4.294.967.296}$ colori. Nello specifico, gli 8 bit meno significativi contengono l'informazione relativa al colore blu (B), i bit da 9 a 16 contengono l'informazione del colore verde (G), i bit da 17 a 24 codificano il valore del rosso (R), infine i bit da 25 a 32 contengono l'informazione del parametro alfa (A), che indica la trasparenza del colore. Nella nostra applicazione non utilizzeremo quest'informazione perché la point cloud è formata solo da punti di colore nero, che viene codificato dal valore più basso, ovvero 0. Per ottenere la modifica appena descritta, cambiamo il parametro della funzione \texttt{CandidatesGenerator::generateGraspCan-}\\\texttt{didates}, che non sarà più una stringa contenente il percorso del file, ma una varibalie di tipo \texttt{const CloudCamera\&}. \par
La seconda modifica che apportiamo riguarda il tipo restituito dalla funzione \texttt{CandidatesGenerator-}\\\texttt{::generateGraspCandidates}, perché non sarà più di tipo \texttt{std::vector<Grasp>} ma \texttt{void}. Il vettore delle prese viene aggiornato passando alla funzione l'indirizzo della variabile da aggiornare, perciò la funzione di partenza avrà un parametro aggiuntivo. \par 
A seguito di queste due modifiche, la segnatura della funzione \texttt{CandidatesGenerator::generate-}\\\texttt{GraspCandidates} è:
\begin{verbatim}
  void CandidatesGenerator::generateGraspCandidates(const CloudCamera&, std::vector-
  <Grasp>&)
\end{verbatim}
e nel main modifichiamo la chiamata della funzione, creando anche una struttura dati di tipo \texttt{std::vec-}\\\texttt{tor<Grasp>} per memorizzare le prese valide:
\begin{verbatim}
  std::vector<Grasp> candidates;
  candidates_generator.generateGraspCandidates(cloud_cam,candidates);
\end{verbatim}
Dopo aver modificato la libreria, è necessario ricompilarla andando ad eseguire l'ultimo comando della sequenza di compilazione illustrata in precedenza, che è: 
\begin{verbatim}
  sudo make install
\end{verbatim}
È estremamente importante ripetere questo passaggio ogni volta che si desidera apportare delle modifiche alla libreria.
\section{Functionalities}
Dopo aver importato e modificato la libreria GPG creiamo il plugin, che servirà per richiamare l'esecuzione della libreria all'interno di un'attività di STAR. Il plugin va creato nella sottocartella \texttt{plugin} della cartella \texttt{Functionalities} di STAR. \par
Tutto quello che serve per creare e far funzionare il nostro plugin si trova nella cartella \texttt{arm\_grasp\_gcg}. Questa cartella contiene a sua volta altre tre cartelle (\texttt{cfg}, \texttt{lib} e \texttt{src}) e un \texttt{makefile}. La cartella \texttt{lib} contiene un file con estensione \texttt{.so} che corrisponde alla libreria dinamica che crea la libreria GPG, la cartella \texttt{cfg} contiene un file che riassume tutti i parametri configurabili della libreria GPG in formato XML, infine la cartella \texttt{src} contiene il file che permette di esportare in STAR la libreria GPG come plugin. \par
Quest'ultimo file, \texttt{PluginArmGraspGCG.cpp} è stato ottenuto copiando e modificando il file della libreria GPG che contiene il metodo \texttt{main} (ovvero \texttt{generate\_candidates.cpp}). Per prima cosa, la funzione \texttt{main} è stata tolta e trasformata in una normale funzione, all'inizio del file si registrano tutti i parametri di configurazione che successivamente vengono inizializzati ed infine si esporta il plugin aggiungendo le seguenti istruzioni: 
\begin{verbatim}
  extern "C" BOOST_SYMBOL_EXPORT PluginArmGraspGCG arm_grasp_gcg;
  PluginArmGraspGCG arm_grasp_gcg;
\end{verbatim}
\indent Successivamente, si crea il \texttt{makefile} che contiene le istruzioni per compilare questo plugin. Le prime istruzioni riguardano il nome della libreria e il file in cui viene richiamata:
\begin{verbatim}
  LIB_NAME       = arm_grasp_gcg
  LIB_SRC        = PluginArmGraspGCG.cpp
\end{verbatim} 
Successivamente, vanno specificati i nomi ed i percorsi delle librerie necessarie affinché il plugin funzioni correttamente. Le dipendenze sono quelle indicate nella sezione \ref{GPG}, perciò specifichiamo il percorso delle librerie \textit{PCL}, \textit{Eigen} e \textit{VTK}. \par
Per quanto riguarda il file di configurazione (\texttt{arm\_grasp\_gcg.cfg}), i parametri di nostro interesse sono:
\begin{itemize}
\item \texttt{finger\_width}: spessore delle dita della pinza utilizzata;
\item \texttt{hand\_outer\_diameter}: diametro della pinza, calcolato come somma fra la massima apertura della pinza e due volte lo spessore delle dita;
\item \texttt{hand\_depth}: lunghezza delle dita della pinza;
\item \texttt{hand\_height}: spessore (inteso come profondità) della pinza;
\item \texttt{voxelize}: variabile booleana che è \texttt{true} se si vuole che i punti della point cloud vengano voxelizati al fine di ridurne il numero, vale \texttt{false} altrimenti;
\item \texttt{remove\_outliers}: variabile booleana utilizzata per indicare se si vogliono tenere tutti i valori (in questo caso il suo valore è \texttt{false}) oppure se si voglio scartare quelli statisticamente lontani al fine di ridurre il rumore della point cloud (in quest'altro caso il valore della variabile è \texttt{true});
\item \texttt{num\_samples}: numero di campioni, ovvero di prese, che si vogliono tenere in considerazione. Nel caso in cui si è interessati ad una sola presa il suo valore è 1, altrimenti è un intero maggiore di 1.
\end{itemize}
Infine, va creata un'interfaccia all'interno della cartella \texttt{Functionalities} in cui richiamiamo la funzione della libreria. Quest'interfaccia va creata nel percorso \texttt{Functionalities/interfaces/star/robo-}\\\texttt{tics/functionality} e contiene gli \texttt{include} necessari e una funzione \texttt{virtual} che richiama la libreria. La sua segnatura è la seguente:
\begin{verbatim}
  virtual void generateGraspCandidates(pcl::PointCloud<pcl::PointXYZRGBA>::Ptr cloud-
  Prova, std::vector<Grasp>\& prese) = 0;}
\end{verbatim} 
Dopo aver costruito il plugin, è necessario compilarlo, eseguendo le seguenti istruzioni:
\begin{verbatim}
  cd STAR/AutonomousRobots/Functionalities/plugin/arm_grasp_gcg
  make
\end{verbatim} 
Il plugin va ricompilato ogni volta che viene modificato. 
\section{Components}
Abbiamo creato due diverse attività: \texttt{ObjectDetection} si occupa dell'utilizzo della libreria GPG e della pubblicazione di messaggi contenenti le informazioni sulla presa, mentre \texttt{ObjectVisualization} si limita a ricevere e a stampare sul terminale il messaggio ricevuto dalla prima attività.
\todo{attività sono ObjectDetection e ObjectVisualization, mentre componente è CameraZedServer}
\section{Messages}
Per quanto riguarda i messaggi, per la nostra applicazione è risultato necessario utilizzare i messaggi di tipo \texttt{manipulation\_msgs} disponibili nella cartella \texttt{Messages} di STAR e in particolare abbiamo dovuto introdurre nel file \texttt{manipulation\_msgs.idl} una nuova tipologia di struttura dati denominata \texttt{GraspCandidates}. Questa struttura consente di contenere al suo interno le possibili pinze individuate dalla libreria GPG ed è composta a sua volta da un campo corrispondente a una sequenza di oggetti di tipo \texttt{GraspPose}. Questa è un'ulteriore struttura dati che abbiamo creato in modo da rappresentare la singola pinza ed è costituita da tre campi di tipo \texttt{Transform3D}, che a sua volta è una nuova struttura dati introdotta che serve per rappresentare la traslazione e la rotazione della pinza. I tre campi della struttura \texttt{GraspPose} si distinguono in base al tipo di traslazione individuata:
\begin{itemize}
	\item \texttt{coord\_bottom}, che contiene le coordinate della traslazione fra il sistema di riferimento della telecamera e la posizione centrata sulla base della pinza del robot;
	\item \texttt{coord\_top}, che contiene le coordinate della traslazione fra il sistema di riferimento della telecamera e la posizione centrale fra le estremità delle dita della pinza del robot;
	\item \texttt{coord\_surface}, che contiene le coordinate della traslazione fra il sistema di riferimento della telecamera e la posizione centrata sulla superficie dell'oggetto.
\end{itemize}
L'ultima struttura dati creata, \texttt{Transform3D}, è formata da 7 campi di tipo double, di cui i primi tre permettono di rappresentare le traslazioni (x, y e z, chiamati rispettivamente a, b e c per avere dei nomi univoci), mentre gli ultimi quattro rappresentano le rotazioni espresse sotto forma di quaternioni (x, y, z e w). \par
Una volta apportate le precedenti modifiche al file \texttt{manipulation\_msgs.idl}, è necessario ricompilare i messaggi tramite i seguenti comandi in un nuovo terminale:
\begin{verbatim}
  cd STAR/AutonomousRobots/Messages
  . compile.sh
\end{verbatim}
La compilazione va eseguita tutte le volte che si modificano i messaggi.

\newpage
\chapter{Risultati}\label{risultati}
Immagini con prese, eventualmente anche quelle con integrazione robot.
%----------------------------------------------------------------------------------------

\end{document}
