
\documentclass{report}

\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{import}
\usepackage{todonotes}
\usepackage{color}
\usepackage{rotating}
\usepackage[hidelinks]{hyperref}
\usepackage{url}
\usepackage{pdfpages}
\usepackage{siunitx}
\usepackage{pdflscape}
\usepackage{subfig}
\usepackage[euler]{textgreek}
\usepackage{mhchem}

\usepackage{multirow}

\usepackage{enumerate} 
\usepackage{amsmath}
\usepackage{amsfonts}

\usepackage[signatures,swapnames,sans]{frontespizio}

\usepackage{geometry}
\geometry{portrait, margin=3cm}
\usepackage{siunitx}
\usepackage{booktabs}

\renewcommand*\figurename{Figura}

\newcommand{\sub}[1]{\textsubscript{#1}}
\newcommand{\super}[1]{\textsuperscript{#1}}
\newcommand{\parallelsum}{\mathbin{\!/\mkern-5mu/\!}}

\newcommand{\Fig}[0]{Fig.}

\usepackage{listings} %Per inserire codice
%\usepackage[usenames]{color} %Per permettere la colorazione dei caratteri

\lstnewenvironment{codice_arduino}[1][]
{\lstset{basicstyle=\small\ttfamily, columns=fullflexible,
keywordstyle=\color{red}\bfseries, commentstyle=\color{blue},
language=C++, basicstyle=\small,
numbers=left, numberstyle=\tiny,
stepnumber=2, numbersep=5pt, float=*, #1}}{}

\usepackage{titlesec}

\titleformat{\chapter}{\normalfont\huge}{}{20pt}{\huge\bfseries}

\linespread{1.3}


%% COMANDI UTILI
%\begin{table}[h]
%	\centering
%	\begin{tabular}{|c|c|c|}
%	\cline{2-3} 
%	\multicolumn{1}{c|}{} & \textbf{Valore nominale} & \textbf{Valore misurato}\\ 
%		%\hline
%		%{} & \textbf{Valore nominale} & \textbf{Valore misurato} \\ 
%		\hline
%		$\mathbf{R_1}$ & \SI{18}{k\ohm} & \SI{17.977}{k\ohm} \\ 
%		\hline
%		$\mathbf{R_2}$& \SI{1.8}{k\ohm} & \SI{1.815}{k\ohm} \\ 
%		\hline
%	\end{tabular}
%\caption{Misure delle resistenze utilizzate per il circuito.}
%\label{table:mis_res}
%\end{table}
%\begin{figure}[h!]
%\centering
%\includegraphics[height=6.5cm]{immagini/TEK00018}\\(a)\\[1ex]
%\includegraphics[height=6.5cm]{immagini/TEK00019}\\(b)
%\caption{Risposta del circuito con accoppiamento DC (a) e accoppiamento AC (b).}
%	\label{figura:accopp}
%\end{figure}

\begin{document}
%\addtocounter{chapter}{+4}
	\begin{frontespizio}
		\Margini{3cm}{3cm}{3cm}{3cm}
		\Universita{Bergamo}
		\Logo[43.332mm]{unibg-mark}
		\Divisione{Scuola di Ingegneria}
		\Corso[Laurea Magistrale]{Ingegneria Informatica}
		\Titolo{Laboratorio di Robotica}
		\Sottotitolo{Documentazione attività di laboratorio }
		\Punteggiatura{}
		\NRelatore{Prof.}{Prof.}
		\Relatore{Davide Brugali}
		\Candidato[1058231]{Giulia Allievi}
		\Candidato[1059640]{Martina Fanton}
		\Annoaccademico{2022--2023}
		\begin{Preambolo*}
			\usepackage[italian]{babel}
			\usepackage[T1]{fontenc}
			\usepackage[utf8]{inputenc}
			\usepackage{microtype}
			\usepackage{lmodern}
			\graphicspath{{img/}}
			
			\renewcommand{\frontinstitutionfont}{\fontsize{14}{17}\bfseries\scshape}
			\renewcommand{\fronttitlefont}{\fontsize{17}{21}\bfseries\scshape}
			\renewcommand{\frontfootfont}{\fontsize{12}{14}\bfseries\scshape}
		\end{Preambolo*}
	\end{frontespizio}

%----------------------------------------------------------------------------------------
%	PAGINA BIANCA
%----------------------------------------------------------------------------------------
%\newpage
%\null
%\thispagestyle{empty}
%\newpage

%----------------------------------------------------------------------------------------
%	INDICE
%----------------------------------------------------------------------------------------
\tableofcontents

%----------------------------------------------------------------------------------------
%	INTRO
%----------------------------------------------------------------------------------------
\chapter{Introduzione}
L'obiettivo del nostro progetto è quello di fornire le coordinate e l'orientamento della pinza ad un robot, al fine di potersi posizionare per afferrare un oggetto. Le coordinate e l'orientamento vengono calcolate da un'opportuna libreria (nel nostro caso dalla libreria \textit{Grasp Pose Generator, GPG}), la quale necessità delle informazioni dell'oggetto inquadrato sottoforma di una nuvola di punti, la point cloud, che verrà fornita attraverso la \textit{Stereo Camera ZED}. Il software del progetto sarà realizzato utilizzando il \textit{Framework STAR}. \par
La Stereo Camera ZED è dotata di vari sensori, per esempio l'accelereometro e il giroscopio, ma nella nostra applicazione serviranno solo i dati delle immagini, in particolare solo quelli della point cloud. La fotocamera stereoscopica ha un range di profondità compreso fra \SI{30}{c\meter} e \SI{20}{\meter} (fonte: \textcolor{blue}{\underline{\href{https://www.stereolabs.com/assets/datasheets/zed2-camera-datasheet.pdf}{datasheet}}}), perciò gli oggetti dovranno essere inquadrati ad una distanza compresa in questo intervallo. \par
Di seguito, nel capitolo \ref{librerie} verranno analizzate due diverse librerie che si possono utilizzare per ottenere i dati relativi alla posizione e all'orientamento della pinza del robot, mentre nel capitolo \ref{integrazione} verranno descritti i passi necessari per integrare, compilare ed eseguire il progetto. Infine, nel capitolo \ref{risultati}, verranno mostrati i risultati finali.
\newpage
\chapter{Librerie}\label{librerie}
Prima di costruire l'applicazione finale, sono state analizzate due diverse librerie \textit{stand-alone}, la \textit{Grasp Pose Generator}, GPG, la cui documentazione è reperibile al seguente \textcolor{blue}{\underline{\href{https://github.com/atenpas/gpg}{link}}}, e la \textit{Grasp Pose Detector}, GPD, la cui documentazione è invece disponibile al seguente \textcolor{blue}{\underline{\href{https://github.com/atenpas/gpd}{link}}}.\par
\todo{Per entrambe, riportare i comandi di compilazione ed esecuzione per ottenere la versione stand alone. Mettere i link, spiegare GPG e per GPD descrivere solo le differenze con la libreria precedente. Sempre per entrambe, alla fine mettere un'immagine con la visualizzazione delle prese e delle info date dal terminale. }
\section{Grasp Pose Generator, GPG}\label{GPG}
librerie necessarie al funzionamento
\section{Grasp Pose Detector, GPD}\label{GPD}

\newpage
\chapter{Integrazione}\label{integrazione}
In questo capitolo, verranno descritti i passi seguiti per ottenere l'applicazione finale. Prima di utilizzare un nuovo terminale, è importante inizializzare le variabili d'ambiente di STAR. Per fare ciò, bisogna eseguire questi comandi nel terminale:
\begin{verbatim}
  cd STAR
  cd AutonomousRobots
  . env-star.sh
\end{verbatim}
A questo punto, si inserisce la password (che è \texttt{unibg}) ed il terminale è pronto per essere utilizzato. 
\section{Libraries}
Per prima cosa, andiamo a copiare e compilare la libreria GPG descritta nella sezione precedente nella sottocartella \texttt{others} della cartella \texttt{Libraries} di STAR. Per fare ciò eseguiamo i seguenti comandi in un terminale, dopo aver raggiunto la cartella \texttt{others}:
\begin{verbatim}
  cd <location_of_your_workspace>  
  cd grasp_candidates_generator
  mkdir build && cd build
  cmake ..
  make
  sudo make install
\end{verbatim}
Per eseguire la libreria, digitare il comando seguente all'interno della cartella \texttt{build} e sostituire \texttt{some\_cloud} con il nome del file contenente la point cloud:
\begin{verbatim}
  ./generate_candidates ../cfg/params.cfg ~/gpg/tutorials/some_cloud.pcd
\end{verbatim}
La libreria appena importata funziona fornendogli in ingresso un file con estensione \texttt{.pcd} che contiene le informazioni sui punti della point cloud, però nel nostro caso la point cloud non sarà salvata su un file, ma verrà fornita dalla fotocamera stereoscopica. Modifichiamo quindi la libreria per fare in modo che riceva in ingresso non un file, ma una struttura dati denominata \texttt{Cloudcamera} che è un riferimento alla struttura dati \texttt{pcl::PointCloud$<$pcl::PointXYZRGBA$>$::Ptr}. Quest'ultima variabile è un vettore contenente dei punti nel formato XYZRGBA: ogni punto è caratterizzato da 4 campi, i primi tre (X, Y, e Z) sono di tipo double e contengono le informazioni relative alle coordinate di quel punto in metri, invece l'ultimo campo, RGBA, è un intero senza segno a 32 bit in cui si codifica l'informazione sul colore, ogni parametro del colore (R, G, B e A) è memorizzato in 8 bit, questo significa che ognuno di questi valori può variare da 0 a 255, perciò possono essere rappresentati fino a $\displaystyle{2^{32}=4.294.967.296}$ colori. Nello specifico, gli 8 bit meno significativi contengono l'informazione relativa al colore blu (B), i bit da 9 a 16 contengono l'informazione del colore verde (G), i bit da 17 a 24 codificano il valore del rosso (R), infine i bit da 25 a 32 contengono l'informazione del parametro alfa (A), che indica la trasparenza del colore. Nella nostra applicazione non utilizzeremo quest'informazione perché la point cloud è formata solo da punti di colore nero, che viene codificato dal valore più basso, ovvero 0. Per ottenere la modifica appena descritta, cambiamo il parametro della funzione \texttt{CandidatesGenerator::generateGraspCan-}\\\texttt{didates}, che non sarà più una stringa contenente il percorso del file, ma una varibalie di tipo \texttt{const CloudCamera\&}. \par
La seconda modifica che apportiamo riguarda il tipo restituito dalla funzione \texttt{CandidatesGenerator-}\\\texttt{::generateGraspCandidates}, perché non sarà più di tipo \texttt{std::vector<Grasp>} ma \texttt{void}. Il vettore delle prese viene aggiornato passando alla funzione l'indirizzo della variabile da aggiornare, perciò la funzione di partenza avrà un parametro aggiuntivo. \par 
A seguito di queste due modifiche, la segnatura della funzione \texttt{CandidatesGenerator::generate-}\\\texttt{GraspCandidates} è:
\begin{verbatim}
  void CandidatesGenerator::generateGraspCandidates(const CloudCamera&, std::vector-
  <Grasp>&)
\end{verbatim}
e nel main modifichiamo la chiamata della funzione, creando anche una struttura dati di tipo \texttt{std::vec-}\\\texttt{tor<Grasp>} per memorizzare le prese valide:
\begin{verbatim}
  std::vector<Grasp> candidates;
  candidates_generator.generateGraspCandidates(cloud_cam,candidates);
\end{verbatim}
Dopo aver modificato la libreria, è necessario ricompilarla andando ad eseguire l'ultimo comando della sequenza di compilazione illustrata in precedenza, che è: 
\begin{verbatim}
  sudo make install
\end{verbatim}
È estremamente importante ripetere questo passaggio ogni volta che si desidera apportare delle modifiche alla libreria.
\section{Functionalities}
Dopo aver importato e modificato la libreria GPG creiamo il plugin, che servirà per richiamare l'esecuzione della libreria all'interno di un'attività di STAR. Il plugin va creato nella sottocartella \texttt{plugin} della cartella \texttt{Functionalities} di STAR. \par
Tutto quello che serve per creare e far funzionare il nostro plugin si trova nella cartella \texttt{arm\_grasp\_gcg}. Questa cartella contiene a sua volta altre tre cartelle (\texttt{cfg}, \texttt{lib} e \texttt{src}) e un \texttt{makefile}. La cartella \texttt{lib} contiene un file con estensione \texttt{.so} che corrisponde alla libreria dinamica che crea la libreria GPG, la cartella \texttt{cfg} contiene un file che riassume tutti i parametri configurabili della libreria GPG in formato XML, infine la cartella \texttt{src} contiene il file che permette di esportare in STAR la libreria GPG come plugin. \par
Quest'ultimo file, \texttt{PluginArmGraspGCG.cpp} è stato ottenuto copiando e modificando il file della libreria GPG che contiene il metodo \texttt{main} (ovvero \texttt{generate\_candidates.cpp}). Per prima cosa, la funzione \texttt{main} è stata tolta e trasformata in una normale funzione, all'inizio del file si registrano tutti i parametri di configurazione che successivamente vengono inizializzati ed infine si esporta il plugin aggiungendo le seguenti istruzioni: 
\begin{verbatim}
  extern "C" BOOST_SYMBOL_EXPORT PluginArmGraspGCG arm_grasp_gcg;
  PluginArmGraspGCG arm_grasp_gcg;
\end{verbatim}
\indent Successivamente, si crea il \texttt{makefile} che contiene le istruzioni per compilare questo plugin. Le prime istruzioni riguardano il nome della libreria e il file in cui viene richiamata:
\begin{verbatim}
  LIB_NAME       = arm_grasp_gcg
  LIB_SRC        = PluginArmGraspGCG.cpp
\end{verbatim} 
Successivamente, vanno specificati i nomi ed i percorsi delle librerie necessarie affinché il plugin funzioni correttamente. Le dipendenze sono quelle indicate nella sezione \ref{GPG}, perciò specifichiamo il percorso delle librerie \textit{Eigen, OpenCV, VTK} e \textit{PCL}. \par
Per quanto riguarda il file di configurazione (\texttt{arm\_grasp\_gcg.cfg}), i parametri di nostro interesse sono:
\begin{itemize}
\item \texttt{finger\_width}: spessore delle dita della pinza utilizzata;
\item \texttt{hand\_outer\_diameter}: diametro della pinza, calcolato come somma fra la massima apertura della pinza e due volte lo spessore delle dita;
\item \texttt{hand\_depth}: lunghezza delle dita della pinza;
\item \texttt{hand\_height}: spessore (inteso come profondità) della pinza;
\item \texttt{voxelize}: variabile booleana, è \texttt{true} se si vuole che i punti della point cloud vengano voxelizati al fine di ridurne il numero, vale \texttt{false} altrimenti;
\item \texttt{remove\_outliers}: variabile booleana utilizzata per indicare se si vogliono tenere tutti i valori (in questo caso il suo valore è \texttt{false}) oppure se si voglio scartare quelli statisticamente lontani, al fine di ridurre il rumore della point cloud (in quest'altro caso il valore della variabile è \texttt{false});
\item \texttt{num\_samples}: numero di campioni, ovvero di prese, che si vogliono tenere in considerazione. Nel caso in cui si è interessati ad una sola prese il suo valore è 1, altrimenti è un intero maggiore.
\end{itemize}
Infine, va creata un'interfaccia all'interno della cartella \texttt{Functionalities} in cui richiamiamo la funzione della libreria. Quest'interfaccia va creata nel percorso \texttt{Functionalities/interfaces/star/robo-}\\\texttt{tics/functionality}, contiene gli \texttt{include} necessari e una funzione virtuale che richiama la libreria. La sua segnatura è la seguente:
\begin{verbatim}
  virtual void generateGraspCandidates(pcl::PointCloud<pcl::PointXYZRGBA>::Ptr cloud-
  Prova, std::vector<Grasp>\& prese) = 0;}
\end{verbatim} 
Dopo aver costruito il plugin, è necessario compilarlo, eseguento le seguenti istruzioni:
\begin{verbatim}
  cd STAR/AutonomousRobots/Functionalities/plugin/ arm_grasp_gcg
  make
\end{verbatim} 
Il plugin va ricompilato ogni volta che viene modificato. 
\section{Components}
Abbiamo creato due diversi ATTIVITA' [sistema terminologia], il componente che si occupa dell'utilizzo della libreria e della pubblicazione dei messaggi contenenti le informazioni sulla presa è \texttt{ObjectDetection}, mentre il componente \texttt{ImageVisualization} si limita a ricevere e stampare sul terminale il messaggio ricevuto dal primo componente.
\section{Messages}
3 messaggi creati con vari campi.

\newpage
\chapter{Risultati}\label{risultati}
Immagini con prese, eventualmente anche quelle con integrazione robot.
%----------------------------------------------------------------------------------------

\end{document}
